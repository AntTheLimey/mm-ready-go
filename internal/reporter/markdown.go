package reporter

import (
	"fmt"
	"sort"
	"strings"

	"github.com/AntTheLimey/mm-ready/internal/models"
)

// RenderMarkdown renders the report as Markdown.
func RenderMarkdown(report *models.ScanReport) string {
	var lines []string

	// Header
	lines = append(lines, "# MM-Ready: Spock 5 Readiness Report")
	lines = append(lines, "")
	lines = append(lines, fmt.Sprintf("**Database:** %s  ", report.Database))
	lines = append(lines, fmt.Sprintf("**Host:** %s:%d  ", report.Host, report.Port))
	lines = append(lines, fmt.Sprintf("**PostgreSQL:** %s  ", report.PGVersion))
	lines = append(lines, fmt.Sprintf("**Scan Time:** %s  ", report.Timestamp.Format("2006-01-02 15:04:05 UTC")))
	lines = append(lines, fmt.Sprintf("**Target:** Spock %s", report.SpockTarget))
	lines = append(lines, "")

	// Summary
	lines = append(lines, "## Summary")
	lines = append(lines, "")
	lines = append(lines, "| Metric | Count |")
	lines = append(lines, "|--------|-------|")
	lines = append(lines, fmt.Sprintf("| Checks Run | %d |", report.ChecksTotal()))
	lines = append(lines, fmt.Sprintf("| Checks Passed | %d |", report.ChecksPassed()))
	lines = append(lines, fmt.Sprintf("| **CRITICAL** | **%d** |", report.CriticalCount()))
	lines = append(lines, fmt.Sprintf("| WARNING | %d |", report.WarningCount()))
	lines = append(lines, fmt.Sprintf("| CONSIDER | %d |", report.ConsiderCount()))
	lines = append(lines, fmt.Sprintf("| INFO | %d |", report.InfoCount()))
	lines = append(lines, "")

	// Readiness verdict
	if report.CriticalCount() == 0 && report.WarningCount() == 0 {
		lines = append(lines, "> **READY** — No critical or warning issues found.")
	} else if report.CriticalCount() == 0 {
		lines = append(lines, "> **CONDITIONALLY READY** — No critical issues, but warnings should be reviewed.")
	} else {
		lines = append(lines, fmt.Sprintf("> **NOT READY** — %d critical issue(s) must be resolved.", report.CriticalCount()))
	}
	lines = append(lines, "")

	// Findings by severity
	allFindings := report.Findings()
	for _, sev := range []models.Severity{models.SeverityCritical, models.SeverityWarning, models.SeverityConsider, models.SeverityInfo} {
		var sevFindings []models.Finding
		for _, f := range allFindings {
			if f.Severity == sev {
				sevFindings = append(sevFindings, f)
			}
		}
		if len(sevFindings) == 0 {
			continue
		}

		lines = append(lines, fmt.Sprintf("## %s (%d)", sev.String(), len(sevFindings)))
		lines = append(lines, "")

		// Group by category
		catSet := make(map[string]bool)
		for _, f := range sevFindings {
			catSet[f.Category] = true
		}
		var categories []string
		for cat := range catSet {
			categories = append(categories, cat)
		}
		sort.Strings(categories)

		for _, cat := range categories {
			var catFindings []models.Finding
			for _, f := range sevFindings {
				if f.Category == cat {
					catFindings = append(catFindings, f)
				}
			}

			lines = append(lines, fmt.Sprintf("### %s", cat))
			lines = append(lines, "")

			for _, finding := range catFindings {
				lines = append(lines, fmt.Sprintf("#### %s", finding.Title))
				lines = append(lines, "")
				if finding.ObjectName != "" {
					lines = append(lines, fmt.Sprintf("**Object:** `%s`  ", finding.ObjectName))
				}
				lines = append(lines, fmt.Sprintf("**Check:** %s", finding.CheckName))
				lines = append(lines, "")
				lines = append(lines, finding.Detail)
				lines = append(lines, "")
				if finding.Remediation != "" {
					lines = append(lines, fmt.Sprintf("**Remediation:** %s", finding.Remediation))
					lines = append(lines, "")
				}
				lines = append(lines, "---")
				lines = append(lines, "")
			}
		}
	}

	// Errors
	var errors []models.CheckResult
	for _, r := range report.Results {
		if r.Error != "" {
			errors = append(errors, r)
		}
	}
	if len(errors) > 0 {
		lines = append(lines, "## Errors")
		lines = append(lines, "")
		for _, r := range errors {
			lines = append(lines, fmt.Sprintf("- **%s/%s**: %s", r.Category, r.CheckName, r.Error))
		}
		lines = append(lines, "")
	}

	// Footer
	lines = append(lines, "---")
	lines = append(lines, "*Generated by mm-ready v0.1.0*")

	return strings.Join(lines, "\n")
}
